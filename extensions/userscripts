/*
 * userscripts extension 
 *
 * TODO not done yet
 *
 *
 * Config: An array of paths to userscripts
 *
 * Example (loading with extensions load):
 * 
 * extensions.load("userscripts", { scripts : [ "/path/to/script1", "/path/to/script2" ] });
 *
 * Example (extensionsrc): 
 *
 * return {
 *   ... : {  ...  },  // other config objects 
 *   
 *   userscripts : { scripts : [ "/path/to/script1", "/path/to/script2" ] },
 *
 *   ... : {  ...  }  // other config objects 
 * }
 *
 * */

var me = "userscripts";
var onStart = []; 
var onEnd = []; 
var scripts;

function UserScript() 
{
  this.description = null;
  this.downloadURL = null;
  this.exclude = [];
  this.icon = null;
  this.include = [];
  this.match = [];
  this.name = null;
  this.namespace = null;
  this.require = [];
  this.resource = [];
  this.runAt = "document-end";
  this.unwrap = false;
  this.updateURL = null;
  this.version = null;
  this.script = null;
}

// Reused regular expressions
var regexes = {
  isTld : /\.tld(?:\/|:|$)/, 
  isRegExp : /^\/.*\/$/
};

function inject(wv, item) //{{{
{
  var i;
  var frames = wv.allFrames;
  if (frames === null || frames === undefined || frames.length === 0) {
    wv.mainFrame.inject(item.script, item.unwrap);
  }
  else {
    for (i=0; i<frames.length; i++) {
      frames[i].inject(item.script, item.unwrap);
    }
  }
}//}}}

function matchIncludeExclude(wv, items) //{{{
{
  var uri = wv.uri;
  var domain = wv.mainFrame.domain;
  var i;
  for (i=0; i<items.length; i++) {
    try {
      if (items[i].isTld && domain !== null) {
        var reg = new RegExp("(?=.)" + domain + "($|/|:)");
        var newDomain = domain.substring(0, domain.indexOf(".")) + ".tld$1";
        uri = uri.replace(reg, newDomain);
      }
      if (items[i].regExp.test(uri)) {
        return true;
      }
    }
    catch(e) {
      extensions.error(me, e);
    }
  }
  return false;
}//}}}

function matchMatches(wv, items) //{{{
{
  var i, item;
  var o = uriSplit(wv.uri);
  if (o === null)
    return false;
  for (i=0; i<items.length; i++) {
    item = items[i];
    if (item.allUrls || 
        (item.scheme.test(o.scheme)  &&  
        item.host.test(o.host)      &&  
        (o.path === null  || item.path.test(o.path)))) {
      return true;
    }

  }
  return false;
}//}}}

function handleItem(wv, item) //{{{
{
  var includes, excludes, matches;
  var o;
  try {
    if (matchIncludeExclude(wv, item.exclude)) 
      return;

    if (matchIncludeExclude(wv, item.include)) {
      inject(wv, item);
    }
    else if (matchMatches(wv, item.match)) {
      inject(wv, item);
    }
  }
  catch (e) {
    extensions.error(me, e);
  }
}//}}}

function handle(wv, array) //{{{
{
  var i, j;
  for (i=0; i<array.length; i++) {
    try {
      handleItem(wv, array[i]);
    }
    catch (e) {
      extensions.debug(me);
    }
  }
}//}}}

function loadFinishedCallback(wv) //{{{
{
  handle(wv, onEnd);
}//}}}

function loadCommittedCallback(wv) //{{{
{
  handle(wv, onStart);
}//}}}

function parseIncludeExclude(array) //{{{
{
  var i, rule;
  for (i=0; i<array.length; i++) {
    rule = array[i];
    if (regexes.isRegExp.test(rule)) {
      array[i] = { regExp : new RegExp(rule.substring(1, rule.length-1)), isTld : regexes.isTld.test(rule) };
    }
    else {
      array[i] = { regExp : new RegExp(rule.replace(/\*/g, ".*")), isTld : regexes.isTld.test(rule) };
    }
  }
}//}}}

function uriSplit(uri) 
{
  var parts, scheme, host, path, idx; 
  parts = uri.split("://");
  if (parts[0] === uri) 
    return null;
  scheme = parts[0];
  idx = parts[1].indexOf("/");
  if (idx == -1) {
    host = parts[1];
    path = null;
  }
  else {
    host = parts[1].substring(0, idx);
    path = parts[1].substring(idx);
  }
  return { path : path, host: host, scheme : scheme }; 
}

function parseMatch(m) 
{
  var i, scheme, host, path, parts, j; 
  if (m === "<all_urls>") {
    return { allUrls : true };
  }

  var o = uriSplit(m);
  if (o === null) {
    extensions.warning(me, "Invalid or unsupported match rule: " + m);
    return null;
  }
  if (!(/\*|http|https|file/.test(o.scheme))) {
    extensions.warning(me, "Invalid scheme pattern: " + m);
    return null;
  }
  else {
    o.scheme = new RegExp(o.scheme.replace("*", ".*"));
  }
  if (! (/^(?:\*\.[^*\/]*|[^*]*|\*)$/.test(o.host))) {
    extensions.warning(me, "Invalid host pattern: " + m);
    return null;
  }
  else {
    o.host = new RegExp(o.host.replace(/([.?+^$[\]\\(){}|-])/g, "\\$1").replace("*", ".*"));
  }
  if (! (/^\/.*/.test(o.path))) { 
    extensions.warning(me, "Invalid path pattern: " + m);
    return null;
  }
  else if (o.path !== null) {
    o.path = new RegExp(o.path.replace(/([.?+^$[\]\\(){}|-])/g, "\\$1").replace("*", ".*"));
  }
  return { host : o.host, scheme : o.scheme, path : o.path, allUrls : false };
}

function parseMetaData(script) //{{{
{
  var i, j, items, key, value, idx, m, matches = [];
  var metaStart = script.search(/(^|\n)\/\/ ==UserScript==/);
  var metaEnd = script.search(/\n\/\/ ==\/UserScript==/);
  if (metaStart == -1 || metaEnd == -1) 
    return false;

  var userscript = new UserScript();

  var meta = script.substring(metaStart, metaEnd).split("\n");
  var scriptStart = script.substring(metaEnd+1).indexOf("\n") + metaEnd + 1;
  userscript.script = script.substring(0, metaStart) + 
    script.substring(scriptStart);

  var regValue = /\s[^\/@]\S?/;
  var regIsRule = /^\s*\/\/\s*@/;
  for (i=1; i<meta.length; i++) {
    if (! (regIsRule.test(meta[i])) )
      continue;
    try {
      items = meta[i].split(" ", 2);
      key = items[1].substring(1).trim();
      idx = meta[i].search(regValue);
      value = idx >= 0 ? meta[i].substring(idx+1).trim() : null;
      if (key == "description"  || 
          key == "downloadURL"  || 
          key == "icon"         || 
          key == "name"         || 
          key == "namespace"    || 
          key == "updateURL"    || 
          key == "version") 
      {
        userscript[key] = value;
      }
      else if (key == "unwrap") 
        userscript.unwrap = true;
      else if (key == "run-at")
        userscript.runAt = value;
      else if (userscript[key] instanceof Array) {
        userscript[key] = userscript[key].concat(value.match(/\S+/g));
      }
    }
    catch(e) {
      extensions.debug(me, e);
    }

  }
  parseIncludeExclude(userscript.include);
  parseIncludeExclude(userscript.exclude);
  
  for (i=0; i<userscript.match.length; i++) {
    m = parseMatch(userscript.match[i]);
    if (m !== null) {
      matches.push(m);
    }
  }
  userscript.match = matches;
  if (userscript.runAt == "document-start")
    onStart.push(userscript);
  else 
    onEnd.push(userscript);
  return true;
}//}}}

function parseScripts() //{{{
{
  var i;
  var userscripts = [];
  var userscript = null;
  var script;
  for (i=0; i<scripts.length; i++) {
    if (io.fileTest(scripts[i], FileTest.regular)) {
      script = io.read(scripts[i]);
      userscript = parseMetaData(script);
    }
  }
  if (onStart.length > 0) {
    signals.connect("loadCommitted", loadCommittedCallback);
  }
  else if (onEnd.length > 0) {
    signals.connect("loadFinished", loadFinishedCallback);
  }
}//}}}

return {
  init : function (c) {
    if (c.scripts instanceof Array && c.scripts.length > 0)  {
      scripts = c.scripts;
      parseScripts();
      return true;
    }
    return false;
  }
};

// vim: set ft=javascript:
