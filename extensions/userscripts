/*
 * userscripts extension 
 *
 * TODO not done yet
 *
 *
 * Config: An array of paths to userscripts
 *
 * Example (loading with extensions load):
 * 
 * extensions.load("userscripts", [ "/path/to/script1", "/path/to/script2" ]);
 *
 * Example (extensionsrc): 
 *
 * return {
 *   ... : {  ...  },  // other config objects 
 *   
 *   userscripts : [ "/path/to/script1", "/path/to/script2" ]
 *
 * }
 *
 * */

var me = "userscripts";
var onStart = []; 
var onEnd = []; 
var scripts;
function UserScript() 
{
  this.description = null;
  this.downloadURL = null;
  this.exclude = [];
  this.icon = null;
  this.include = [];
  this.match = [];
  this.name = null;
  this.namespace = null;
  this.require = [];
  this.resource = [];
  this.runAt = "document-end";
  this.unwrap = false;
  this.updateURL = null;
  this.version = null;
  this.script = null;
}
// Reused regular expressions
var regexes = {
  isTld : /\.tld(?:\/|:|$)/, 
  isRegExp : /^\/.*\/$/
};


function inject(wv, item) //{{{
{
  var i;
  var frames = wv.allFrames;
  if (frames === null || frames === undefined || frames.length === 0) {
    wv.mainFrame.inject(item.script, item.unwrap);
  }
  else {
    for (i=0; i<frames.length; i++) {
      frames[i].inject(item.script, item.unwrap);
    }
  }
}//}}}

function matchIncludeExclude(wv, item) //{{{
{
  var uri = wv.uri;
  if (item.isTld) {
    io.print("TODO: isTld");
    return false;
  }
  else if (item.regExp.test(uri)) {
    return true;
  }
  return false;
}//}}}

function matchMatches(wv, item) //{{{
{
  io.print("TODO: match");
  return false;
}//}}}

function handleItem(wv, item) //{{{
{
  var includes, excludes, matches;
  var i;
  excludes = item.exclude;
  for (i=0; i<excludes.length; i++) {
    if (matchIncludeExclude(wv, excludes[i])) {
      return;
    }
  }
  includes = item.include;
  for (i=0; i<includes.length; i++) {
    if (matchIncludeExclude(wv, includes[i])) {
      inject(wv, item);
      return;
    }
  }
  matches = item.match;
  for (i=0; i<matches.length; i++) {
    if (matchMatches(wv, matches[i])) {
      inject(wv, item);
      return;
    }
  }
}//}}}

function handle(wv, array) //{{{
{
  var i, j;
  for (i=0; i<array.length; i++) {
    try {
      handleItem(wv, array[i]);
    }
    catch (e) {
      io.print(e);
    }
  }
}//}}}

function loadFinishedCallback(wv) //{{{
{
  handle(wv, onEnd);
}//}}}

function loadCommittedCallback(wv) //{{{
{
  handle(wv, onStart);
}//}}}

function parseIncludeExclude(array) //{{{
{
  var i, rule;
  for (i=0; i<array.length; i++) {
    rule = array[i];
    if (regexes.isRegExp.test(rule)) {
      array[i] = { regExp : new RegExp(rule.substring(1, rule.length-1)), isTld : regexes.isTld.test(rule) };
    }
    else {
      array[i] = { regExp : new RegExp(rule.replace(/\*/g, ".*")), isTld : regexes.isTld.test(rule) };
    }
  }
}//}}}

function parseMetaData(script) //{{{
{
  var i, j, items, key, value, idx;
  var metaStart = script.search(/(^|\n)\/\/ ==UserScript==/);
  var metaEnd = script.search(/\n\/\/ ==\/UserScript==/);
  if (metaStart == -1 || metaEnd == -1) 
    return false;

  var userscript = new UserScript();

  var meta = script.substring(metaStart, metaEnd).split("\n");
  var scriptStart = script.substring(metaEnd+1).indexOf("\n") + metaEnd + 1;
  userscript.script = script.substring(0, metaStart) + 
    script.substring(scriptStart);

  var regValue = /\s[^\/@]\S?/;
  var regIsRule = /^\s*\/\/\s*@/;
  for (i=1; i<meta.length; i++) {
    if (! (regIsRule.test(meta[i])) )
      continue;
    try {
      items = meta[i].split(" ", 2);
      key = items[1].substring(1).trim();
      idx = meta[i].search(regValue);
      value = idx >= 0 ? meta[i].substring(idx+1).trim() : null;
      if (key == "description"  || 
          key == "downloadURL"  || 
          key == "icon"         || 
          key == "name"         || 
          key == "namespace"    || 
          key == "updateURL"    || 
          key == "version") 
      {
        userscript[key] = value;
      }
      else if (key == "unwrap") 
        userscript.unwrap = true;
      else if (key == "run-at")
        userscript.runAt = value;
      else if (userscript[key] instanceof Array) {
        userscript[key] = userscript[key].concat(value.match(/\S+/g));
      }
    }
    catch(e) {
      extensions.error(me, e);
    }

  }
  parseIncludeExclude(userscript.include);
  parseIncludeExclude(userscript.exclude);
  if (userscript.runAt == "document-start")
    onStart.push(userscript);
  else 
    onEnd.push(userscript);
  return true;
}//}}}

function parseScripts() //{{{
{
  var i;
  var userscripts = [];
  var userscript = null;
  var script;
  for (i=0; i<scripts.length; i++) {
    if (io.fileTest(scripts[i], FileTest.regular)) {
      script = io.read(scripts[i]);
      userscript = parseMetaData(script);
    }
  }
  if (onStart.length > 0) {
    signals.connect("loadCommitted", loadCommittedCallback);
  }
  else if (onEnd.length > 0) {
    signals.connect("loadFinished", loadFinishedCallback);
  }
}//}}}

return {
  init : function (c) {
    if (c instanceof Array && c.length > 0)  {
      scripts = c;
      parseScripts();
      return true;
    }
    return false;
  }
};

// vim: set ft=javascript:
