/*
 * supergenpass - generate domain based passwords
 *
 * This extension generates domain based passwords using the same algorithm the
 * bookmarklet supergenpass uses but with some additional options. 
 * It takes a masterpassword, creates a unique password for the current domain
 * and injects it into the password field of the active tab.
 *
 *
 * Loading this extension:
 *
 * extensions.load("supergenpass");
 *
 *
 * Config options:
 *
 * compat             : Compatibility mode, always generate passwords that are
 *                      compatible with the original supergenpass bookmarklet
 *                      default : true
 *
 * domainSalts        : Additional salts that are added on a domain basis. 
 *                      domainSalts has to be an object of the form
 *                      { "example.com" : "foo", "example.co.uk" : "bar" }
 *                      In Compatibility mode domain salts are disabled
 *                      default : {}
 *
 * hashMethod         : The hash-algorithm to use, either ChecksumType.md5,
 *                      ChecksumType.sha1 or ChecksumType.sha256, in
 *                      compatibility mode it is set to ChecksumType.md5
 *                      default : ChecksumType.md5
 *
 * length             : Length of the password, the minimum length is 4, the
 *                      maximum length depends on the hashMethod, for md5 it is
 *                      24, for sha1 it is 28 and for sha256 it is 44. 
 *                      default : 10
 *
 * rehash             : Minimum number of rehashes, in compatibility mode it is
 *                      set to 10
 *                      default : 10
 *
 * salt               : A salt that will additionally be added to the password, 
 *                      in compatibility mode set to ""
 *                      default : ""
 *
 * saveMasterPassword : Whether to save the master password or ask every time
 *                      a password is generated
 *                      default : false
 *
 * shortcut           : The shortcut to invoke this extension
 *                      default : "ep"
 *
 * shortcutPrint      : A shortcut that prints the generated password to stdout
 *                      instead of injecting it into the website
 *                      default : ""
 *
 * stripSubdomains    : Whether to strip subdomains
 *                      default : true
 *
 * Example (extensionsrc): 
 *
 * return {
 *   ... : {  ...  },  // other config objects 
 *   
 *   supergenpass : {
 *      compat     : false, 
 *      hashMethod : ChecksumType.sha256, 
 *      rehash     : 1000, 
 *      resalt     : true, 
 *      length     : 16
 *   },
 *
 *   ... : {  ...  }  // other config objects 
 * }
 *
 * Example (loading config with extensions.load): 
 * 
 * extensions.load("supergenpass", { 
*     compat : false, 
 *    hashMethod  : ChecksumType.sha256, 
 *    domainSalts : { "example.com" : "foo", "example.co.uk" : "bar" } 
 * });
 *
 * */

var me = "supergenpass";
var config = {};
var master = null;

var defaultConfig = {
  compat : true,
  length : 10, 
  saveMasterPassword : false, 
  shortcut : "ep",
  shortcutPrint :  "",
  stripSubdomains : true
};
var compat = {
  rehash : 10, 
  hashMethod : ChecksumType.md5,
  salt : "", 
  domainSalts : {}
};


var injectFunction = function (password) {
  var active = document.activeElement;
  if (active instanceof HTMLInputElement && active.type == "password") {
    active.value = password;
  }
  else {
    active = document.body.querySelector("input[type='password']");
    active.value = password;
  }
};

function inject(pass) {
  var frames = tabs.current.allFrames;
  var i;
  for (i = 0; i<frames.length; i++) {
    frames[i].inject("(" + String(injectFunction) + ")('" + pass + "');");
  }
}

/*
 * Converts a hexstring to a base64-encoded string without padding '='. 
 * +/ are replaced with 98
 * */
function hex2base64(string) {
  var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678998";
  var result = new String();
  var i, j, n24;
  for (j=0, n24=0; j<string.length; j+=6, n24=0)  {
    for (i=0; i<3 && (j+i+1) < string.length; i++) {
      n24 += parseInt(string.substring(j+2*i, j+(2*i+2)), 16) << ((2-i)*8);
    }
    result += b64[n24>>18 & 63] + b64[n24>>12 & 63] + b64[n24>>6 & 63] + b64[n24 & 63]; 
  } 
  return result;
}
function base64hash(string) {
  string = checksum(string, config.hashMethod);
  return hex2base64(string);
}

var regValidate = /^[a-z].*(?:[A-Z].*[0-9]|[0-9].*[A-Z]).*/;

function generate() {
  var i, mainFrame, host, salt, pass;

  mainFrame = tabs.current.mainFrame;
  host = config.stripSubdomains ? mainFrame.domain : mainFrame.host;

  salt = config.salt;
  if (config.domainSalts[host]) 
    salt += config.domainSalts[host];
  salt += ":" + host;
  pass = master + salt;

  for (i=0; i<config.rehash || !regValidate.test(pass.substring(0, config.length)); i++) {
    pass = base64hash(pass);
  }
  return pass.substring(0, config.length);
}
function getPassword() {
  var pass = null;
  if (master === null)
    master = io.prompt("Master password:", false);
  if (master === null)
    return pass;
  pass = generate();
  if (! config.saveMasterPassword )
    master = null;
  return pass;
}
function insertPassword() {
  var pass = getPassword();
  inject(pass);
}
function printPassword() {
  var pass = getPassword();
  io.print(pass);
}
function parseConfig(c) {
  var key;
  try {
    if (c === null || c === undefined) {
      for (key in defaultConfig) 
        config[key] = defaultConfig[key];
      for (key in compat) 
        config[key] = compat[key];
    }
    else {
      for (key in defaultConfig) {
        if (typeof defaultConfig[key] === typeof c[key])
          config[key] = c[key];
        else 
          config[key] = defaultConfig[key];
      }
      for (key in compat) {
        if (typeof compat[key] === typeof c[key] && !config.compat)
          config[key] = c[key];
        else 
          config[key] = compat[key];
      }
    }

    var pwdMax;
    switch (config.hashMethod) {
      case ChecksumType.sha256 : pwdMax = 44; break;
      case ChecksumType.sha1   : pwdMax = 28; break;
      default:                   pwdMax = 24; break;
    }
    if (config.password < 4 || config.length > pwdMax)
      extensions.warning(me, "Invalid password length, using " + defaultConfig.length + " instead");

    bind(config.shortcut, insertPassword);
    if (config.shortcutPrint) {
      bind(config.shortcutPrint, printPassword);
    }
  }
  catch (e) {
    extensions.error(me, e);
  }

}
return  {
  init : function (c) {
    parseConfig(c);
    return true;
  }
}
// vim: set ft=javascript:
